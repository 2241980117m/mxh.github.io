---
title: 算法之排序算法总结
date: 2018-03-04 10:06:30
tags:
---
ps:这里的排序都是从小到大进行排列。
<h2>冒泡排序</h2>
<ul>
	<li>算法思想:从第一个数开始，将两个相邻的数进行比较，如果前一个数大于后一个数，则互换位置，否则保持不变。这样比较一趟，可以把最大的数放在末尾(根据循环的趟数决定)。依次循环，直到排序完成。</li>
	<li>时间复杂度:O(n^2)</li>
	<li>空间复杂度:O(1)</li>
</ul>
<h2>选择排序</h2>
<ul>
	<li>算法思想:从待排序的数字中找出最小的数，放在排序数字的最开始，之后依次在未排序的数字中选出最小的数放在已经排序的数字的末尾。</li>
	<li>时间复杂度:O(n^2)</li>
	<li>空间复杂度:O(1)</li>
</ul>
<h2>快速排序</h2>
<ul>
	<li>算法思想:【i表示数组开始下标，j表示数组最后一个元素的下标】可以依赖递归来实现。选取一个基数（可以选取数组的第一个数作为基数），从最后一个数开始遍历，如果小于基数则将该数放在前面（a[i]=a[j,i++)；如果大于基数则将该数放在后面(a[j]=a[i],j++)；直到i==j，循环结束。之后，将开始下标置为0，结束下标置为i-1；开始下标置为i+1,结束下标置为数组长度-1,来实现递归操作。</li>
	<li>时间复杂度:O(nlogn)</li>
	<li>空间复杂度:O(1)</li>
</ul>
<h2>基数排序</h2>
<ul>
	<li>算法思想:首先，决定好需要排序的位数。将所有需要排序的数的每一位分割，根据各位将待排序的数字进行排列，之后根据百位...</li>
	<li>时间复杂度:O(kn)【n表示个数，k表示位数】</li>
	<li>空间复杂度:O(r+n)【r表示桶个数】</li>
</ul>
<h2>归并排序</h2>
<ul>
	<li>算法思想:<br/>
		分解：1.将一个数组分成两个数组。2.循环第一步，直到划分出来的“小数组”只包含一个元素.
		归并：1.将两个有序的数组合并到一个大的数组中。2.从最小的只包含一个元素的数组开始两两合并。此时，合并好的数组也是有序的	
	</li>
	<li>时间复杂度:O(nlogn)</li>
	<li>空间复杂度:O(n)</li>
</ul>
<h2>计数排序</h2>
<ul>
	<li>算法思想:需要临时创建一个数组，该数组的长度由等待排序数据的差决定。将待排序的数与数组的下标相对应，临时数组的值是等待排序的数字中和临时数组下标相等的数据的个数。之后，将临时数组按照数组值将下标一一输出就可完成排序。</li>
	<li>时间复杂度:O(n)</li>
	<li>空间复杂度:O(n)</li>
</ul>
<h2>插入排序</h2>
<ul>
	<li>算法思想:从数字列表中依次选取一个数，与已经排序好的数字从最后一个数开始进行比较，如果准备插入的数小于该数，则将该数往后移一个位置，直到准备插入的数大于或等于该数时，将准备插入的数字放入该数的后面。</li>
	<li>时间复杂度:O(n^2)</li>
	<li>空间复杂度:O(1)</li>
</ul>