---
title: 正则表达式
date: 2016-07-20 17:15:03
tags:
---
- <h2>正则表达式是用来进行文本匹配的工具。</h2>
- <h2>正则表达式的匹配模式支持下列3个标志：</h2>
     &nbsp;&nbsp;&nbsp;&nbsp;1.g:表示全局模式。应用于所有字符串。
     &nbsp;&nbsp;&nbsp;&nbsp;2.i:表示不区分大小写。
     &nbsp;&nbsp;&nbsp;&nbsp;3.m:表示多行模式。在达到文本末尾时，还会继续查找下一行中是否存在与模式匹配的项。
- <h2>正则表达式常用的元字符</h2>
    &nbsp;&nbsp;&nbsp;&nbsp;1.\b:代表单词的开头或末尾，只匹配一个位置。
    &nbsp;&nbsp;&nbsp;&nbsp;2.\d:匹配一个数字。
    &nbsp;&nbsp;&nbsp;&nbsp;3..:匹配换行符以外的任意字符
    &nbsp;&nbsp;&nbsp;&nbsp;4.*：重复次数，至少0次
    &nbsp;&nbsp;&nbsp;&nbsp;5.+：重复次数，至少1次
    &nbsp;&nbsp;&nbsp;&nbsp;6.? 表示匹配0次或者1次
    &nbsp;&nbsp;&nbsp;&nbsp;7.\s:匹配任何不可见的字符（制表符，换页符）
    &nbsp;&nbsp;&nbsp;&nbsp;8.\w:匹配任何非单词的字符（字母，数字，_）
    &nbsp;&nbsp;&nbsp;&nbsp;9.^:字符串的开头
    &nbsp;&nbsp;&nbsp;&nbsp;10.$：字符串的结束
    &nbsp;&nbsp;&nbsp;&nbsp;11.{n,m}:(n<=m) 最少n次，最多m次
    &nbsp;&nbsp;&nbsp;&nbsp;12.[n-m]:匹配指定范围内的任意字符
   &nbsp;&nbsp;&nbsp;&nbsp;13.（）: 用来将复杂的正则表达式分解为多个简单的子表达式。
- <b>注意：模式中所有使用的元字符都必须转义，在[]中元字符可以不用转义；</b>
- <h2>定义正则表达式</h2>
  定义正则表达式有2中方法，分别是：字面量形式，RegExp构造函数
  两者的区别是：正则表达式字面量会共享同一个实例，而用RegExp构造的每一个实例都是一个新实例。如：
  字面量形式
      var a=/.at/g;    //匹配所有的以at结尾的3字符的字符串
  RegExp构造函数
      var b=new RegExp(".at","g")
     a和b是完全等价的，使用RegExp构造函数定义正则表达式，接收2个参数，这两个参数必须是字符串形式，
     且2个参数分别是：匹配的模式，匹配模式的标志。而在字面量中转义的元字符必须在RegExp构造函数中
     双重转义。
- <h2>RegExp实例属性</h2>
  每个实例都会具有以下属性，通过他们可以获得正则表达式的相关信息
    1.global：布尔值，正则表达式是否设定了g标志
    2.ignoreCase:布尔值，正则表达式是否设定了i标志
    3.multiline:布尔值，正则表达式是否设定了m标志
    4.source: 返回正则表达式的字符串表示。按照字面量的形式返回。
    5.lastIndex:整数，表示搜索下一个匹配项的字符位置，从0算起
- <h2>RegExp实例方法</h2>
  1.<b>exec():</b> 接收1个参数，它是应用模式的字符串。返回的是一个数组，数组的第一项是与模式匹配的项，
  其他的是与捕获组匹配的字符串。这个数组具有2个属性，分别是:index(匹配项在数组中的位置)，input
  (应用正则表达式的字符串)。如果匹配模式是全局模式，则每次在字符串数组中继续查找匹配项，且lastIndex每次都不同
  若没有全局标志，则每次返回第一个匹配项的信息。且lastIndex每次为0.
  2.<b>test():</b>接收一个参数，它是应用匹配模式的字符串。若字符串与模式匹配返回true，否则返回false.
  3.<b>toLocalString(),toString():</b> 返回正则表达式的字面量。与定义正则表达式的方式无关。
  4.<b>valueOf():</b>返回正则表达式本身。
- <h2>RegExp构造函数属性</h2>
  可以通过两种方法访问这些属性，即常属性法和短属性法。短属性法除了input外其他都不符合ES的标识符，
  可以通过[]来访问.
    1.input($_):返回最近一次应用于匹配模式的字符串
    2.lastMatch($&):最近一次的匹配项
    3.lastParen($+):最近一次的捕获组
    4.leftContent($`):input字符串中lastMatch之前的文本
    5.rightContent($'):input字符串中lastMatch之后的文本
    6.multiline($*):布尔值，所有表达式是否是否使用多行模式
    此外，还具有9个用于存储捕获组的属性，即RegExp.$1,RegExp.$2...
    <b>$1和\1表示匹配的第一个正则子表达式，常用在回溯引用中。</b>
 
   <hr />

- <h2>前后查找</h2>
    <b>作用：前后查找都可以做到根据一个条件来筛选出一段文本，但筛选出的文本中不包含筛选条件。</b>
    向前查找
       任何表达式都可以转化为向前查找表达式，只需要在它之前加上?=前缀即可。
    向后查找
       向后查找表达式只需要加上?<=前缀即可。
    负向前查找
       负向前查找是匹配不与指定模式相匹配的文本。类似于向前查找。应该使用?!前缀。
    负向后查找
       负向后查找类似于向后查找，匹配不与给定模式相匹配的文本。应该使用?<!前缀。
    <b>在前后查找表达式中，如果根据元字符进行前后查找，则该元字符需要转义。前后查找一般与()配合使用。</b>
- <h2>贪婪型和懒惰型</h2>  
     <b>在正则表达式中，存在贪婪型和懒惰型两种方式，我们可以根据自身需求选择性使用</b>
    以下例子均使用
     `var str="<h1>hello world!</h1><h1>Do you want to go shopping.</h1>"`
     `var pattern="<h1>.*</h1>"`
    贪婪型
      得到的结果是 "<h1>hello world!</h1><h1>Do you want to go shopping.</h1>"
    懒惰型
      得到的结果是 "<h1>hello world!</h1>"
   如何将贪婪型改为懒惰型
       只需要将 "var pattern='<h1>.*</h1>'  改为 '<h1>.*?</h1>'"
    <b>总结: 其实实现正则表达式匹配指定字符很简单，困难的是我们需要筛选出那些不需要的字符，所以在使用正则表达式时一定要考虑周到。</b>
    <hr />
